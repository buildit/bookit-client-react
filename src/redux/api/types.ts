import * as Redux from 'redux'

export interface ErrorAction extends Redux.Action {
  error: boolean
  payload: any
}

export interface Action<TPayload> extends Redux.Action {
  payload: TPayload
}

export interface CreateAction<TPayload> extends Action<TPayload> {
  type: string
  (payload?: TPayload): Action<TPayload>
  matches(action: Redux.Action): action is Action<TPayload>
}

export const createAction = <TPayload>(type: string): CreateAction<TPayload> => {
  const creator: any = <TPayload>(payload?: TPayload) => ({ type, payload })
  creator.matches = <TPayload>(action: Redux.Action): action is Action<TPayload> => action.type === type
  creator.type = type
  return creator as CreateAction<TPayload>
}

export type HttpMethod = 'GET' | 'HEAD' | 'PUT' | 'POST' | 'PATCH' | 'DELETE' | 'OPTIONS'

export interface ICallApiOptions {
  endpoint: string
  method: HttpMethod
  types: string[]
  body?: any
  credentials?: 'omit' | 'same-origin' | 'include'
  headers?: {
    [propName: string]: string
  }
}

export interface ApiAction<TPayload, TResponse> {
  [propName: string]: ICallApiOptions
}

export interface IApiActionOptions {
  RSAA: any
  endpoint: string
  method: HttpMethod
  credentials?: 'omit' | 'same-origin' | 'include'
  headers?: {
    [propName: string]: string
  }
}

export interface CreateApiAsyncAction<TPayload, TResponse> {
  type: string
  (payload?: TPayload): ApiAction<TPayload, TResponse>
  matches(action: Action<any>): action is Action<any>
  matchesPending(action: Action<TPayload>): action is Action<TPayload>
  matchesSuccess(action: Action<TResponse>): action is Action<TResponse>
  matchesFailure(action: Action<any>): action is ErrorAction
}

export type CreateApiActionOptions<TPayload> =
  IApiActionOptions |
  ((payload: TPayload) => IApiActionOptions)

/**
 * Creates an action creator for api middleware actions.
 *
 * @param {string} type - The action type. Used as a prefix for actions generated by the api middleware
 * @param {IApiActionOptions | (payload: TPayload) => IApiActionOptions} options - The options for the api call
 * @param {any} addOn - (optional) Any additional properties you want to set on the action. NOTE: do not use with redux-api-middleware
 */
export const createApiAction =
  <TPayload, TResponse>(type: string, options: CreateApiActionOptions<TPayload>, addOn?: any): CreateApiAsyncAction<TPayload, TResponse> => {
    const pendingType = `${type}_PENDING`
    const successType = `${type}_SUCCESS`
    const failureType = `${type}_FAILURE`

    const creator: any = (payload: TPayload): ApiAction<TPayload, TResponse> => {
      const { RSAA, method, endpoint, credentials, headers }
        = typeof (options) === 'function' ? options(payload) : options
      return {
        [RSAA]: {
          body: method === 'POST' || method === 'PUT' ? payload : undefined,
          credentials,
          endpoint,
          headers,
          method,
          types: [pendingType, successType, failureType],
        },
        ...addOn,
      }
    }
    creator.type = type
    creator.matches = (action: Action<any>): action is Action<any> =>
      action.type === pendingType || action.type === successType || action.type === failureType
    creator.matchesPending =
      (action: Action<TPayload>): action is Action<TPayload> => action.type === pendingType
    creator.matchesSuccess =
      (action: Action<TResponse>): action is Action<TResponse> => action.type === successType
    creator.matchesFailure =
      (action: Action<any>): action is ErrorAction => action.type === failureType
    return creator as CreateApiAsyncAction<TPayload, TResponse>
  }
